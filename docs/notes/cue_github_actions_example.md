# CUE GitHub Actions Example

[![asciinema-cue-github-actions-example](https://asciinema.org/a/688045.svg)](https://asciinema.org/a/688045)

```bash
git clone https://github.com/cue-examples/github-actions-example \
  && cd github-actions-example \
  && git checkout -b github-actions-example 2b9d2f240d0c677c30218282dc10f95dfd566453
cue mod init github.com/cue-examples/github-actions-example
git status
git log -p -n 1

# TODO .bashrc?
export CUE_INSTALL_DIR=cache/install/cue
export KCP_INSTALL_DIR=cache/install/kcp
export PATH="${HOME}/Documents/publicdomainrelay/reference-implementation/${CUE_INSTALL_DIR}:${PATH}"
cue mod init github.com/cue-examples/github-actions-example
cue import ./.github/workflows/ --with-context -p github -f -l workflows: -l 'strings.TrimSuffix(path.Base(filename),path.Ext(filename))'
ls -lAF .github/workflows/
diff <(head -42 .github/workflows/*.yml) <(head -42 .github/workflows/*.cue)
mkdir -vp internal/ci/github
mv ./.github/workflows/*.cue internal/ci/github
cue login
cue mod get github.com/cue-tmp/jsonschema-pub/exp1/githubactions@v0.3.0
cue vet ./internal/ci/github
cat > internal/ci/github/workflows.cue
package github

import "github.com/cue-tmp/jsonschema-pub/exp1/githubactions"

// Each member of the workflows struct must be a valid #Workflow.
workflows: [_]: githubactions.#Workflow
EOF
cue vet ./internal/ci/github
cat > internal/ci/github/ci_tool.cue <<'EOF'
package github

import (
	"path"
	"encoding/yaml"
	"tool/file"
)

_goos: string @tag(os,var=os)

// Regenerate all workflow files
command: regenerate: {
	workflow_files: {
		// TODO: update _toolFile to reflect the directory hierarchy containing this file.
		let _toolFile = "internal/ci/github/ci_tool.cue"
		let _workflowDir = path.FromSlash(".github/workflows", path.Unix)
		let _donotedit = "Code generated by \(_toolFile); DO NOT EDIT."

		clean: {
			glob: file.Glob & {
				glob: path.Join([_workflowDir, "*.yml"], _goos)
				files: [...string]
			}
			for _, _filename in glob.files {
				"Delete \(_filename)": file.RemoveAll & {path: _filename}
			}
		}

		create: {
			for _workflowName, _workflow in workflows
			let _filename = _workflowName + ".yml" {
				"Generate \(_filename)": file.Create & {
					$after: [for v in clean {v}]
					filename: path.Join([_workflowDir, _filename], _goos)
					contents: "# \(_donotedit)\n\n\(yaml.Marshal(_workflow))"
				}
			}
		}
	}
}
EOF

cd $(git rev-parse --show-toplevel)
cue help cmd regenerate ./internal/ci/github || test 1
cue cmd regenerate ./internal/ci/github

git diff .github/workflows/
git add .github/workflows/ internal/ci/github/ cue.mod/module.cue
git commit -m "ci: create CUE sources for GHA workflows"

# To update in the
cd $(git rev-parse --show-toplevel)
cue cmd regenerate ./internal/ci/github/
git add .github/workflows/ internal/ci/github/
git commit -m "ci: added new release workflow" # example message
```

## References

- [publicdomainrelay/reference-implementation#8: docs: adrs: governance: Policies](https://github.com/publicdomainrelay/reference-implementation/issues/8)
- [cue by example: Driving GitHub Actions workflows with CUE](https://github.com/cue-labs/cue-by-example/blob/7d70a5b5ea03c23c9ef88f47573475ee25fcf847/001_github_actions_importing_workflows/README.md)
  - Upstream: Docs from this link ^
  - Overlay(s):
    - Phase 1: GitHub Workflows + GitHub Secrets
    - Phase 2: Federated (SCITT) Policy Engine (Secrets from Python Keyring)
    - Phase 3: Federated Forgejo Secrets
  - Orchestrator(s):
    - Phase 1: GitHub SaaS
    - Phase 2: (SCITT) Policy Engine (This will become the "firewall" to Forgejo)
    - Phase 3: Forgejo
